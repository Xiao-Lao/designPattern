# Design Patterns

This repository contains implementations of various design patterns in Java. Design patterns are typical solutions to common problems in software design. They represent best practices and are a toolkit of solutions that can be used to solve common software design problems.

## Implemented Patterns
- Observer Pattern âœ…

## Design Patterns Overview

### Creational Patterns
These patterns provide ways to create objects while hiding the creation logic, making the system independent of how its objects are created and composed.

- **Singleton**: Ensures a class has only one instance and provides a global point of access to it.
- **Factory Method**: Creates objects without specifying the exact class to create.
- **Abstract Factory**: Creates families of related objects without specifying their concrete classes.
- **Builder**: Separates the construction of a complex object from its representation.
- **Prototype**: Creates new objects by copying an existing object.

### Structural Patterns
These patterns explain how to assemble objects and classes into larger structures while keeping these structures flexible and efficient.

- **Adapter**: Allows objects with incompatible interfaces to collaborate.
- **Bridge**: Separates an abstraction from its implementation so that they can vary independently.
- **Composite**: Composes objects into tree structures to represent part-whole hierarchies.
- **Decorator**: Adds responsibilities to objects dynamically.
- **Facade**: Provides a simplified interface to a complex subsystem.
- **Flyweight**: Reduces the cost of creating and manipulating a large number of similar objects.
- **Proxy**: Provides a substitute or placeholder for another object to control access to it.

### Behavioral Patterns
These patterns are concerned with algorithms and the assignment of responsibilities between objects.

- **Chain of Responsibility**: Passes a request along a chain of handlers until one handles it.
- **Command**: Turns a request into a stand-alone object containing all information about the request.
- **Interpreter**: Implements a specialized language for a problem domain.
- **Iterator**: Accesses elements of a collection without exposing its underlying representation.
- **Mediator**: Reduces chaotic dependencies between objects by restricting direct communications and forcing collaboration through a mediator object.
- **Memento**: Saves and restores the previous state of an object without revealing implementation details.
- **Observer**: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified.
- **State**: Allows an object to alter its behavior when its internal state changes.
- **Strategy**: Defines a family of algorithms, encapsulates each one, and makes them interchangeable.
- **Template Method**: Defines the skeleton of an algorithm, deferring some steps to subclasses.
- **Visitor**: Separates algorithms from the objects on which they operate.

## Future Implementations
More pattern implementations will be added progressively to this repository.
